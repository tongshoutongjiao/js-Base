<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>详解组件状态管理</title>
</head>

<body>
    <div>
        在第 18 讲中我们详细分析了组件的 3 个要素：数据模型、渲染和视图。虽然通过组件化的方式能够有效地将 Web 页面进行解耦，但另一个问题也随之出现，组件之间如何进行通信。这一讲我们就来分析组件化 Web
        应用中的组件通信问题。
    </div>
    <div>
        <h2>全局状态</h2>
        <div>
            对于父子组件通信，框架都已给出可行的解决方案：父组件通过 prop(s)
            属性向子组件传参，子组件通过自定义事件来向父组件发送消息。而非父子组件之间，如果通过层层传递，这个过程就会变得相当麻烦。最简单的直接解决方式就是设置一个供多个组件共享的全局变量，但如果直接使用全局变量会存在一些问题，比如：

            可能多个组件会同时修改变量值，这个过程无法追踪，调试问题也会变得很麻烦；

            当全局变量值发生变化时，如何通知引用它的每一个组件？
        </div>
    </div>
    <div>
        <h2>1 状态管理库的特点</h2>
        <div>针对这些问题，一些状态管理库出现了，我们重点分析用于 Vue 的 Vuex 和用于 React 的 Redux，所谓的“状态”，就是不同组件之间传递和引用的数据模型。状态管理库具有 3
            个特点：可预测、中心化、可调式。
        </div>
    </div>
    <div>
        <h2>可预测 </h2>
        <div>可预测性指的是，如果状态 A 经过操作 B 会生成状态 C，那么不论在任何时刻、任何平台（客户端、服务端、App 端），只要 A 和 B 不发生变化，就能得到同样的结果 C。比如下面代码中的函数就是不可预测的：
            `function getTime() {
            return new Date().getTime()
            }
            function getDom(id) {
            return document.getElementById(id)
            } ` <br>

            getTime() 函数在不同时刻会得到不同的值，getDom() 函数只能在网页上运行，所以结果都是不可预测的。而下面的函数都是可预测的：
            function nextDay(time) {
            return new Date(time + 1000 * 60 * 60 * 24)
            }
            function filter(a, b) {
            return a + b
            } <br>
            可预测性只是纯函数的优势之一，后面我们在讲函数式编程的时候再详细介绍纯函数相关的内容。
        </div>

    </div>
    <div>
        <h2>中心化 </h2>
        <div>Vuex 和 Redux 都只会构建一棵中心化的状态树，所有的状态数据都会作为子属性挂载到这棵树上，非常有默契。

        </div>
    </div>
    <div>
        <h2>可调式 </h2>
        <div>可调式指的是可以利用浏览器插件，对状态的变化和使用情况进行追踪和调试。Vuex 提供了 Vue.js devtools插件，Redux 也提供了 Redux DevTools。

        </div>
    </div>
    <div>
        <h2>2.状态管理库实现原理 </h2>
        <div>了解状态管理库特性之后，我们再对写和读这两个核心操作的源码进行分析。 </div>
    </div>
    <div>
        <h2>其他组件通信方式 </h2>
        <div>选用状态管理库并不是解决跨组件传递数据的唯一方式，下面再介绍 2 种方式也能提供跨组件通信，以 Vue 为例进行讲解。

        </div>
        <h2>1.全局上下文 </h2>
        <div>在 Vue 中，提供了一组 API 用来解决祖先组件与子孙组件的通信问题，那就是 provide 和 inject。provide
            可以在祖先组件中指定我们想要提供给子孙组件的数据或方法，而在任何子孙组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法。

        </div>
        <h2>2.事件监听 </h2>
        <div>事件监听则是利用组件库本身的事件机制，设置一个全局事件代理，用来负责向各个组件传递数据。 </div>


    </div>
    <div>
        <h2>总结</h2>
        <div>
            本讲介绍了 3 种不同的跨组件通信方式。由于通信双方不属于父子组件，也就是没有直接的依赖/引用关系，所以需要借助“第三方”来进行传递数据，这些“第三方”既包括视图库（Vue 和
            React）本身提供的事件机制或全局上下文，也包括面向其进行开发的状态管理库。

            对于最常用的全局状态管理库 Vuex 和 Redux，通过深入分析其源码，理解了其实现原理。Vuex 内部会创建一个 Vue 实例，并使用这个实例的数据模型来做状态更新；而 Redux
            则采用了无副作用的纯函数来生成不可变数据。

            组件库默认提供了全局上下文的方式来解决跨组件通信问题，非常轻量，适合在小型 Web
            应用中使用，缺点是追踪调试状态变化比较困难。事件监听的方式也可以不依赖额外的第三方库来实现，但在监听到事件改变时需要在组件内部手动触发视图更新。


        </div>
    </div>


</body>

</html>