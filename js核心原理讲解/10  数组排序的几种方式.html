<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h2>数组排序是你在 JavaScript 的编程过程中经常会遇到的，也是大厂面试中会考察的，
        <p>
            数据结构中稳定的排序算法有哪些？不稳定的排序算法有哪些？
            时间复杂度和空间复杂度分别代表了什么？


        </p>
    </h2>
    <script type="text/javascript">
        // 数组排序

        // 1 冒泡排序
        // 冒泡排序是最基础的排序，一般在最开始学习数据结构的时候就会接触它。

        //  
        let arr = [1, 2, 4, 5, 78, 65, 34, 76, 2, 6, 98, 343, 3232, 646443]
        // function bubbleSort(arr){
        //     if(!Array.isArray(arr)){
        //         console.log('请输入数组')
        //     }
        //     const len = arr.length
        //    if (len < 2) return arr

        //     // 冒泡排序的逻辑 
        //     for(let i=0;i<len-1;i++){
        //         for(let j=0;j<len-i-1;j++){
        //             if(arr[j]>arr[j+1]){
        //                 [arr[j],arr[j+1]]=[arr[j+1],arr[j]]
        //             }  
        //         }
        //     }


        //     return arr
        // }

        // let sortArr=bubbleSort(arr);
        // console.log('查看排序后的结果');
        // console.log(sortArr);

        //     var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
        // function bubbleSort(array) {
        //   const len = array.length
        //   if (len < 2) return array
        //   for (let i = 0; i < len; i++) {
        //     for (let j = 0; j < i; j++) {
        //       if (array[j] > array[i]) {
        //         const temp = array[j]
        //         array[j] = array[i]
        //         array[i] = temp
        //       }
        //     }
        //   }
        //   return array
        // }
        // let b=bubbleSort(a);  // [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]
        // console.log('查看排序结果');
        // console.log(b)


        // 2 快速排序
        // 快速排序的基本思想是通过一趟排序，将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序
        // 下面的代码在控制台执行之后，也可以得到预期的结果。最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成，这就是快排的思路。



        // function quickSort(array) {
        //     console.log('快速排序');
        //     let quick = function (arr) {
        //         if(arr.length<=1) return arr;
        //         const len=arr.length;
        //         const index=Math.floor(len>>1);
        //         debugger;
        //         console.log('查看索引数字')
        //         console.log(index)
        //         const pivot=arr.splice(index,1)[0];
        //         const left=[];
        //         const right=[];
        //         for(let i=0;i<len;i++){
        //             if(arr[i]<pivot){
        //                 left.push(arr[i])
        //             }else if(arr[i]>=pivot){
        //                 right.push(arr[i])
        //             }
        //         }



        //         return quick(left).concat([pivot],quick(right))

        //     }
        //     const result = quick(array)
        //     return result;

        // }





        // function quickSort(array) {
        //     var quick = function (arr) {
        //         if (arr.length <= 1) return arr
        //         const len = arr.length
        //         const index = Math.floor(len >> 1)
        //         const pivot = arr.splice(index, 1)[0]
        //         const left = []
        //         const right = []
        //         for (let i = 0; i < len; i++) {
        //             if (arr[i] > pivot) {
        //                 right.push(arr[i])
        //             } else if (arr[i] <= pivot) {
        //                 left.push(arr[i])
        //             }
        //         }
        //         return quick(left).concat([pivot], quick(right))
        //     }
        //     const result = quick(array)
        //     return result
        // }

        // let res = quickSort(arr);
        // console.log('查看结果');
        // console.log(res);

        // 插入排序
        // 插入排序算法描述的是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，从而达到排序的效果。

        // function insertSort(arr){
        //     console.log('插入排序')
        //     console.log(arr);
        //     const len=arr.length;
        //     let current,prev;
        //     for(let i=1;i<len;i++){
        //         current=arr[i];
        //         prev=i-1;
        //         while(i>=0&&arr[prev]>current){
        //             arr[prev+1]=current;
        //             prev--;
        //         }
        //         arr[prev+1]=current;

        //     }



        //     return arr;

        // }
        //  let res = insertSort(arr);
        // console.log('查看结果');
        // console.log(res);

        // 选择排序
        // 选择排序是一种简单直观的排序算法。它的工作原理是，
        // 首先将最小的元素存放在序列的起始位置，再从剩余未排序元素中继续寻找最小元素，然后放到已排序的序列后面……以此类推，直到所有元素均排序完毕。请看下面的代码。



        // function selectSort(arr) {
        //     console.log('arr');
        //     console.log(arr);
        //     const len = arr.length;
        //     let temp, minIndex

        //     for (let i = 0; i < len - 1; i++) {
        //         minIndex = i;
        //         for (let j = i + 1; j < len; j++) {
        //             if (arr[j] < arr[minIndex]) {
        //                 minIndex = j
        //             }
        //         }
        //         [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
        //     }
        //     return arr;

        // }

        // let res = selectSort(arr);
        // console.log('查看结果');
        // console.log(res);

        // 堆排序 
        // 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵完全二叉树，可以用数组实现。

        // function heap_sort(arr) {
        //     let len = arr.length;
        //     var k = 0;

        //     function swap(i, j) {
        //         var temp = arr[i]
        //         arr[i] = arr[j]
        //         arr[j] = temp
        //     }

        //     function max_heapify(start, end) {
        //         var dad = start
        //         var son = dad * 2 + 1
        //         if (son >= end) return
        //         if (son + 1 < end && arr[son] < arr[son + 1]) {
        //             son++
        //         }
        //         if (arr[dad] <= arr[son]) {
        //             swap(dad, son)
        //             max_heapify(son, end)
        //         }
        //     }
        //     for (var i = Math.floor(len / 2) - 1; i >= 0; i--) {
        //         max_heapify(i, len)
        //     }

        //     for (var j = len - 1; j > k; j--) {
        //         swap(0, j)
        //         max_heapify(0, j)
        //     }

        //     return arr
        // }

        // 归并排序
        // 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。我们先看一下代码。

        function mergeSort(array) {
            const merge = (right, left) => {
                const result=[];
                let il=0;
                let ir=0;
                while(il<left.length&&ir<right.length){
                    if(left[il]<right[ir]){
                        result.push(left[il++])
                    }else{
                        result.push(right[ir++])
                    }
                }
                while(il<left.length){
                    result.push(left[il++])
                }
                while(ir<right.length){
                    result.push(right[ir++])
                }

                return result;

            }
            // 分而治之,
            const mergeSort = array => {
                if (array.length === 1) { return array }
                let mid=Math.floor(array.length/2);
                let left=array.slice(0,mid);
                let right=array.slice(mid,arr.length);

                console.log('查看索引')
                console.log(left,right);
             return  merge(mergeSort(left),mergeSort(right))
            }
            return mergeSort(array)
        }

        // function mergeSort(array) {
        //     const merge = (right, left) => {
        //         const result = []
        //         let il = 0
        //         let ir = 0
        //         while (il < left.length && ir < right.length) {
        //             if (left[il] < right[ir]) {
        //                 result.push(left[il++])
        //             } else {
        //                 result.push(right[ir++])
        //             }
        //         }
        //         while (il < left.length) {
        //             result.push(left[il++])
        //         }
        //         while (ir < right.length) {
        //             result.push(right[ir++])
        //         }
        //         return result
        //     }
        //     const mergeSort = array => {
        //         if (array.length === 1) {
        //             return array
        //         }
        //         const mid = Math.floor(array.length / 2)
        //         const left = array.slice(0, mid)
        //         const right = array.slice(mid, array.length)
        //         return merge(mergeSort(left), mergeSort(right))
        //     }
        //     return mergeSort(array)
        // }







        let res = mergeSort(arr);
        console.log('查看结果');
        console.log(res);
    </script>

</body>

</html>