<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h2>
        上一个模块我们学习了 JS 数组相关的知识，那么从这一讲开始就进入一个崭新的模块，也是 JS 学习过程中比较重要的部分——JS 异步编程
    </h2>
    <div>
        <p> 1 同步编程和异步编程的区别在哪里？ </p>
        <p>2 回调地狱有哪些方法可以解决？</p>
        <div>
            <p> 什么是同步？</p>
            所谓的同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的，但是一旦执行完成拿到返回值之后，就可以执行其他代码了。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行，这样的情况称为同步。
        </div>
        <div>
            <p> 什么是异步？</p>
            所谓异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步调用发出后，不会影响阻塞后面的代码执行，这样的情形称为异步。
        </div>
        <div>
            <p> JS 编程中为什么需要异步？ </p>
            我们都知道 JavaScript 是单线程的，如果 JS 都是同步代码执行意味着什么呢？这样可能会造成阻塞，如果当前我们有一段代码需要执行时，如果使用同步的方式，那么就会阻塞后面的代码执行；而如果使用异步则不会阻塞，我们不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑。因此在 JS 编程中，会大量使用异步来进行编程，这也是我要专门讲解这部分的原因。
        </div>

        <div>
            <p>promise</p>
            为了解决回调地狱的问题，之后社区提出了 Promise 的解决方案，ES6 又将其写进了语言标准，采用 Promise 的实现方式在一定程度上解决了回调地狱的问题。
        </div>
        <div>
            <p>Generator</p>
            Generator 也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注。Generator 函数一般配合 yield 使用，Generator 函数最后返回的是迭代器。如果你对迭代器不太了解，可以自行补习一下这部分内容。

        </div>
        <div>
            <p>async/await</p>
            ES6 之后 ES7 中又提出了新的异步解决方案：async/await，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链），可以处理回调地狱的问题。async/await 写起来使得 JS 的异步代码看起来像同步代码，其实异步编程发展的目标就是让异步逻辑的代码看起来像同步一样容易理解。
        </div>

    </div>


    <script>
        // async/await
        //  用同步的方式来写异步的代码



    </script>

</body>

</html>